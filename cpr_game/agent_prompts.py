"""Agent prompt templates and builders for Common Pool Resource Game.

This module contains functions to construct prompts for LLM agents
based on game state, history, and configuration.
"""

from typing import Dict, List, Optional, Optional


def build_game_prompt(
    observation: Dict,
    player_id: int,
    action_history: List[int],
    config: Dict,
    history_rounds: int
) -> str:
    """Construct LLM prompt from observation and history.

    Args:
        observation: Current game state observation containing:
            - resource_level: Current resource amount
            - step: Current step number
            - my_recent_extractions: Player's recent extraction history
            - other_players_recent_extractions: Other players' extraction history
            - my_cumulative_payoff: Player's total earnings
            - other_players_cumulative_payoffs: Other players' total earnings
        player_id: ID of the current player
        action_history: List of past actions taken by this player
        config: Configuration dictionary with game parameters
        history_rounds: Number of history rounds to include

    Returns:
        str: Formatted prompt for LLM
    """
    resource = observation["resource_level"][0]
    step = observation["step"][0]
    my_extractions = observation["my_recent_extractions"]
    other_extractions = observation["other_players_recent_extractions"]
    my_payoff = observation["my_cumulative_payoff"][0]
    other_payoffs = observation["other_players_cumulative_payoffs"]
    
    # Check if compact prompts are enabled (default: True)
    compact_prompts = config.get("compact_prompts", True)
    step_num = step + 1

    if compact_prompts:
        # Compact format: Rnd {step+1} | R:{resource:.0f} | P{player_id}
        # Rules are in system prompt, not repeated here
        prompt = f"Rnd {step_num} | R:{resource:.0f} | P{player_id}\n\n"
    else:
        # Legacy verbose format (includes rules for backward compatibility)
        prompt = f"""=== Common Pool Resource Game - Round {step_num} ===

We are playing a game of Common Pool Resource. 

The rules of the game are as follows:
- Your goal is to extract as much resource as possible throughout the whole game.  
- There are {config["n_players"]} players in the game.
- Each round, each player extract 0-{config["max_extraction"]} units
- The resource level is regenerated by {config["regeneration_rate"]} units per round
- The game ends when the resource level is {config["min_resource"]} or the maximum number of rounds is reached. 
- If the resource level is {config["min_resource"]}, you will not earn any reward anymore.
- You are player {player_id}.
- The number of rounds is unknown to you. 
- You have a history of your own actions and rewards, and the history of other players' actions and rewards.
- Please think step by step and reason about your action and the chosen amount.

Resource Status:
- Current resource level: {resource:.2f}

"""

    # Add history if available
    if len(action_history) > 0:
        history_length = min(len(action_history), history_rounds)
        if compact_prompts:
            # Compact format: My:[5,3,7]
            history_values = [str(action_history[-(history_length-i)]) for i in range(history_length)]
            prompt += f"My:[{','.join(history_values)}]\n"
        else:
            # Legacy verbose format
            prompt += "Your History (last few rounds):\n"
            for i in range(history_length):
                idx = -(history_length - i)
                round_num = len(action_history) + idx
                extraction = action_history[idx]
                prompt += f"- Round {round_num}: Extracted {extraction}\n"
            prompt += "\n"

    # Add other players' history if enabled and available
    # Conditional: only show if show_other_players_actions is True and there's history
    if config.get("show_other_players_actions", False) and len(action_history) > 0 and other_extractions.shape[0] > 0:
        n_other_players = other_extractions.shape[1]
        history_length = min(len(action_history), history_rounds)
        
        if compact_prompts:
            # Compact format: P0:[5,3] P1:[7,2]
            other_history_parts = []
            for player_idx in range(n_other_players):
                player_num = player_idx if player_idx < player_id else player_idx + 1
                player_extractions = []
                for i in range(history_length):
                    obs_idx = i
                    if obs_idx < other_extractions.shape[0]:
                        extraction = int(other_extractions[obs_idx, player_idx])
                        if extraction > 0:  # Only show non-zero extractions
                            player_extractions.append(str(extraction))
                if player_extractions:  # Only add if there are non-zero extractions
                    other_history_parts.append(f"P{player_num}:[{','.join(player_extractions)}]")
            if other_history_parts:
                prompt += " ".join(other_history_parts) + "\n"
        else:
            # Legacy verbose format
            prompt += "Other Players' History:\n"
            for player_idx in range(n_other_players):
                prompt += f"- Player {player_idx if player_idx < player_id else player_idx + 1}:\n"
                for i in range(history_length):
                    idx = -(history_length - i)
                    round_num = len(action_history) + idx
                    obs_idx = i
                    if obs_idx < other_extractions.shape[0]:
                        extraction = other_extractions[obs_idx, player_idx]
                        if extraction > 0 or round_num >= 0:
                            prompt += f"  Round {round_num}: Extracted {int(extraction)}\n"
            prompt += "\n"

    # Add current standings (conditional: skip if early in game - first 2 rounds)
    if step >= 2 or not compact_prompts:
        if compact_prompts:
            # Compact format: Payoffs: Me:{x} P0:{y} P1:{z}
            payoff_parts = [f"Me:{my_payoff:.0f}"]
            for i, payoff in enumerate(other_payoffs):
                player_num = i if i < player_id else i + 1
                payoff_parts.append(f"P{player_num}:{payoff:.0f}")
            prompt += f"Payoffs: {' '.join(payoff_parts)}\n"
        else:
            # Legacy verbose format
            prompt += "Current Standings:\n"
            prompt += f"- Your total earnings: {my_payoff:.2f}\n"
            for i, payoff in enumerate(other_payoffs):
                player_num = i if i < player_id else i + 1
                prompt += f"- Player {player_num}'s total earnings: {payoff:.2f}\n"
            prompt += "\n"

    # Add instructions
    max_extraction = config["max_extraction"]
    if compact_prompts:
        # Compact instructions
        prompt += f"Extract (0-{int(max_extraction)}). Provide reasoning and action."
    else:
        # Legacy verbose instructions
        prompt += f"""Instructions:
1. Analyze the current situation carefully
2. Consider the resource level and available extraction
3. Think about what other players might do
4. Decide how much to extract this round (0-{int(max_extraction)})
5. Your extraction amount must be a whole number (integer)
6. Explain your reasoning briefly

Provide your response with:
- reasoning: Your explanation for the chosen action
- action: The extraction amount as an integer (0 to {int(max_extraction)})"""

    return prompt


def build_delta_prompt(
    observation: Dict,
    previous_observation: Optional[Dict],
    player_id: int,
    action_history: List[int],
    config: Dict,
    history_rounds: int
) -> str:
    """Build incremental prompt with only changes from previous round.
    
    This function creates a compact delta prompt that only includes
    what changed since the last round, significantly reducing token usage.
    
    Args:
        observation: Current game state observation
        previous_observation: Previous round's observation (None for first round)
        player_id: ID of the current player
        action_history: List of past actions taken by this player
        config: Configuration dictionary with game parameters
        history_rounds: Number of history rounds to include
        
    Returns:
        str: Compact delta prompt with only changes
    """
    resource = observation["resource_level"][0]
    step = observation["step"][0]
    my_payoff = observation["my_cumulative_payoff"][0]
    other_payoffs = observation["other_players_cumulative_payoffs"]
    step_num = step + 1
    
    # First round: send minimal info
    if previous_observation is None or step == 0:
        return f"Rnd {step_num} | R:{resource:.0f} | P{player_id}\nExtract (0-{config['max_extraction']})."
    
    # Subsequent rounds: only send changes
    prev_resource = previous_observation["resource_level"][0]
    prev_step = previous_observation["step"][0]
    prev_my_payoff = previous_observation["my_cumulative_payoff"][0]
    prev_other_payoffs = previous_observation["other_players_cumulative_payoffs"]
    
    delta_parts = [f"Rnd {step_num}"]
    
    # Resource change
    if abs(resource - prev_resource) > 0.1:
        delta_parts.append(f"R:{resource:.0f}")
    
    # New action (last one in history)
    if len(action_history) > 0:
        last_action = action_history[-1]
        delta_parts.append(f"LastExt:{last_action}")
    
    # Payoff changes (only if significant)
    if abs(my_payoff - prev_my_payoff) > 0.1:
        delta_parts.append(f"Pay:{my_payoff:.0f}")
    
    # Other players' payoffs (only if changed significantly)
    payoff_changes = []
    for i, (payoff, prev_payoff) in enumerate(zip(other_payoffs, prev_other_payoffs)):
        if abs(payoff - prev_payoff) > 0.1:
            player_num = i if i < player_id else i + 1
            payoff_changes.append(f"P{player_num}:{payoff:.0f}")
    
    if payoff_changes:
        delta_parts.extend(payoff_changes)
    
    prompt = " | ".join(delta_parts) + f"\nExtract (0-{config['max_extraction']})."
    return prompt

