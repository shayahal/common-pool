# Cursor Rules for Common Pool Resource Game

## Virtual Environment

- Always run the agent in the conda base environment
- Activate the environment using: `/Users/shayyahal/miniconda3/bin/activate base` or `.venv` directly under the root folder.
- Ensure all Python commands and scripts are executed within this activated environment
- Always find the most relevant virtual environment to use for the project

## Logging Guidelines

### Always Use Logs, Never Print
- **NEVER** use `print()` statements in production code
- **ALWAYS** use the logger from `cpr_game.logger_setup import get_logger`
- Replace all `print()` calls with appropriate logger calls

### Log Level Usage

1. **DEBUG** - Use for:
   - Flow steps and detailed execution traces
   - API calls and their details (tokens, latency, cost)
   - Internal state changes and intermediate operations
   - Detailed diagnostic information

2. **INFO** - Use for:
   - Main events only (game start/end, experiment start/end, major milestones)
   - High-level progress updates
   - Important state changes that users should know about

3. **WARNING** - Use for:
   - Unexpected or undesired behavior that was EXPLICITLY REQUESTED to be non-fatal
   - Configuration issues or missing OPTIONAL features (only if user asked for graceful degradation)
   - **NOTE**: Most "warnings" should actually be errors! When in doubt, use ERROR and raise.

4. **ERROR** - Use for:
   - Actual errors that prevent normal operation
   - Exceptions and failures
   - Critical issues that require attention
   - **ANY operation that fails, even if you think it might be recoverable**

### Logging Configuration

The logging system uses separate file handlers for each log level:
- `logs/debug.log` - DEBUG level and above
- `logs/info.log` - INFO level and above
- `logs/warning.log` - WARNING level and above
- `logs/error.log` - ERROR level and above
- `stdout` - All levels (DEBUG and above, configurable via STDOUT_LOG_LEVEL env var)

Each file handler captures its level and all levels above it.

### Third-Party Library Loggers

Third-party libraries (httpx, urllib3, requests, openai, etc.) are automatically configured
to WARNING level to suppress verbose HTTP request/response logging. These are implementation
details, not application-level events.

**IMPORTANT**: HTTP request logs (like "HTTP Request: POST https://...") are NOT INFO level.
They are low-level implementation details and should be suppressed or logged at DEBUG/WARNING.
If you see third-party libraries logging at INFO, configure their loggers in `logger_setup.py`.

### Examples

```python
from cpr_game.logger_setup import get_logger

logger = get_logger(__name__)

# Flow step - use DEBUG
logger.debug("Processing round 5...")
logger.debug(f"API call successful: {tokens} tokens, {latency:.2f}s")

# Main event - use INFO
logger.info("Game started: game_123")
logger.info("Experiment completed: 10 games successful")

# Unexpected behavior - use WARNING
logger.warning("Could not claim experiment (already claimed)")
logger.warning("Database connection retry failed, will retry")

# Error - use ERROR
logger.error("Failed to initialize database", exc_info=True)
logger.error(f"API call failed: {error}")
```

## Error Handling Rules

### ⚠️⚠️⚠️ CRITICAL: ABSOLUTE ZERO TOLERANCE FOR SILENT FAILURES ⚠️⚠️⚠️

**THIS IS THE #1 RULE. THE HIGHEST PRIORITY. VIOLATIONS ARE COMPLETELY UNACCEPTABLE.**

**NEVER. EVER. UNDER ANY CIRCUMSTANCES. ALLOW ANY FAILURE TO BE SILENT.**

- **NEVER EVER EVER** implement silent errors or warnings
- **NEVER EVER** use `try-except` blocks without reraising the exception
- **NEVER EVER** simply print or log an error and then `pass`, `continue`, or `return` silently
- **NEVER EVER** use `logger.warning()` or `logger.info()` or `logger.debug()` as an excuse to continue after a failure
- **NEVER EVER** return `None`, `[]`, `{}`, or any default value after catching an exception
- **ALWAYS ALWAYS ALWAYS** propagate errors by raising exceptions
- **ALWAYS** log at ERROR level with `exc_info=True` before raising
- If you catch an exception, you MUST:
  1. Log it at ERROR level with `exc_info=True`
  2. Raise it (using `raise` or `raise RuntimeError(...) from e`)
  3. **THERE IS NO EXCEPTION TO THIS RULE** (except for interface contracts like OpenTelemetry SpanExporter.export() which must return a result - but even then, log at ERROR)

**THE ONLY ACCEPTABLE PATTERN:**
```python
try:
    operation()
except Exception as e:
    logger.error(f"Operation failed: {e}", exc_info=True)
    raise RuntimeError(f"Operation failed: {e}") from e
```

### Common Anti-Patterns to NEVER Use

1. **Database/schema creation failures** - ALWAYS raise, never warn and continue
2. **Index creation failures** - ALWAYS raise, never warn and continue  
3. **API call failures** - ALWAYS raise, never warn and continue
4. **JSON parsing failures** - ALWAYS raise, never warn and continue
5. **File operations** - ALWAYS raise, never warn and continue
6. **Connection failures** - ALWAYS raise, never warn and continue

### Examples of FORBIDDEN Patterns

```python
# ❌ FORBIDDEN: Silent error suppression
try:
    risky_operation()
except Exception:
    pass  # NEVER DO THIS

# ❌ FORBIDDEN: Log and ignore
try:
    risky_operation()
except Exception as e:
    logger.error(f"Error: {e}")  # Logging alone is not enough
    pass  # NEVER DO THIS

# ❌ FORBIDDEN: Catch and continue silently
try:
    risky_operation()
except Exception:
    logger.warning("Operation failed, continuing...")  # Silent warning
    continue  # NEVER DO THIS without explicit user request

# ❌ FORBIDDEN: Warning as excuse to continue
try:
    create_database_index()
except Exception as e:
    logger.warning(f"Could not create index: {e}")  # WRONG!
    # Code continues... WRONG!

# ❌ FORBIDDEN: Fallback without raising
try:
    parse_json_response()
except json.JSONDecodeError:
    logger.warning("Failed to parse JSON")
    return default_value  # WRONG! Should raise!
```

### Examples of CORRECT Patterns

```python
# ✅ CORRECT: Reraise the exception
try:
    risky_operation()
except Exception:
    raise  # Always reraise unless explicitly handling

# ✅ CORRECT: Transform and reraise
try:
    risky_operation()
except ValueError as e:
    raise CustomError("Operation failed") from e

# ✅ CORRECT: Log then raise
try:
    create_database_index()
except Exception as e:
    logger.error(f"Failed to create index: {e}", exc_info=True)
    raise RuntimeError("Index creation failed") from e

# ✅ CORRECT: Handle completely (only if user explicitly requested)
try:
    optional_operation()
except Exception as e:
    logger.warning(f"Optional operation failed: {e}")
    # Only acceptable if user explicitly asked to suppress this error
    return default_value
```

## langfuse_graphrag Module Rules

The `langfuse_graphrag/` module follows the same rules as the main codebase:

### Logging
- Use `logging.getLogger(__name__)` for module-level loggers
- The CLI (`langfuse_graphrag/cli.py`) sets up file handlers for logs/
- Third-party loggers (httpx, openai, neo4j) are suppressed to WARNING level

### Error Handling  
- **ALL** Neo4j operations MUST raise on failure (no silent index creation failures!)
- **ALL** OpenAI API calls MUST raise on failure
- **ALL** JSON parsing MUST raise on failure
- If a feature requires a specific Neo4j version, the code MUST fail clearly with an error message, not silently degrade
- Use `skip_vector_indexes=True` config option if user wants to explicitly skip vector indexes

### ⚠️⚠️⚠️ CRITICAL: NO FALLBACKS, NO FEATURE FLAGS, NO SUBOPTIMAL FLOWS ⚠️⚠️⚠️

**THIS IS ABSOLUTELY FORBIDDEN. NO EXCEPTIONS.**

- **NEVER EVER** implement fallback logic or alternative code paths
- **NEVER EVER** use try-except to catch errors and try a different method
- **NEVER EVER** implement feature flags or conditional behavior based on capabilities
- **NEVER EVER** create "graceful degradation" or "best effort" code paths
- **NEVER EVER** have multiple ways to do the same thing (e.g., "try method A, if it fails try method B")
- **NEVER EVER** silently continue with a suboptimal approach if the optimal one fails
- **ALWAYS** use the single, correct, optimal method
- **ALWAYS** fail immediately and clearly if requirements aren't met
- If a feature requires specific capabilities (e.g., Neo4j 5.11+ Enterprise), the code MUST fail with a clear error message explaining the requirement
- **THERE IS NO EXCEPTION TO THIS RULE**

**FORBIDDEN PATTERNS:**
```python
# ❌ FORBIDDEN: Fallback logic
try:
    optimal_method()
except:
    suboptimal_method()  # NEVER DO THIS

# ❌ FORBIDDEN: Feature flags
if has_capability:
    use_optimal()
else:
    use_fallback()  # NEVER DO THIS

# ❌ FORBIDDEN: Multiple code paths
try:
    method_a()
except:
    try:
        method_b()
    except:
        method_c()  # NEVER DO THIS
```

**CORRECT PATTERN:**
```python
# ✅ CORRECT: Single method, fail clearly if requirements not met
optimal_method()  # If this fails, the error propagates immediately
```

